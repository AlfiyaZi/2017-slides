<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Prehistoric Patterns in Python</title><meta charset="UTF-8"></meta><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="css/stylesheet.css" media="screen,projection"></link><script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        showProcessingMessages: false,
        messageStyle: "none",
        TeX : { extensions : ['color.js'] }
      });
    </script></head><body class="impress-not-supported"><div id="impress" auto-console="false"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="prehistoric-patterns-in-python">Prehistoric Patterns in Python</h1><p class="name">Lennart Regebro</p><p>PyCon US 2017, Portland</p><div class="notes"><p>Hi! So yes, I'm Lennart Unpronouncable, I've been working with Python
fulltime since 2001.</p></div></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><img src="images/cover.png"></img><div class="notes"><p>And I wrote the book on how to move from Python 2 to Python 3.
It's open source, on github.</p></div></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><img src="images/magda_elenor.jpg" width="70%" class="left"></img><img src="images/elenor_quince.jpg" width="29.5%" class="right"></img><img src="images/cats.jpg" width="50%" class="left"></img><img src="images/quince.jpg" width="50%" class="right"></img><div class="notes"><p>I'm born in Sweden, but I live in Poland, with my
wife, daughter, cats and fruit trees.</p></div></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><p class="blurb">Shoobx is the only comprehensive platform for incorporation, employee
onboarding, equity management, fundraising, board &amp; stockholder
communication, and more.</p><div class="notes"><p>I work for Boston company Shoobx. We make a webapp that helps you with a
lot of the legal documentation for corporations.</p><p>If you don't understand what that elevator blurb says, don't worry about
it, your bosses will. Tell them about us.</p><p>But enough about me!</p></div></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><img src="images/python-logo-0.png" width="10%" class="left"></img><img src="images/python-logo-1.png" class="left"></img><h1 id="id1">&gt;&gt;</h1><img src="images/python-logo-2.png"></img><div class="notes"><p>This talk is going to be about old code patterns.</p><p>Because has Python gained more features, so some things we used to do
make no more sense. But there is loads of old code out there, so I will
try to explain why that old code looks like it does.</p><p>And old does not mean unmaintained. If you wrote a library that needed to
support Python 2.4 old patterns may very well remain, because they still
work. So you might very well encounter this in maintained code.</p><p>And, old tutorials and old books have old patterns. And people keep using
them and learning them.</p><p>So if you are using these patterns, don't feel bad, I won't judge you.</p></div></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><img src="images/judge.jpg"></img><p>[Yes I will]</p><div class="notes"><p>Let's start! And let's start with dictionaries.</p></div></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><pre class="highlight code python"><span class="k">if</span> <span class="n">mydict</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">x</span><span class="p">):</span></pre><div class="notes"><p>OK, firstly, stop using has_key().</p></div></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><pre class="highlight code python"><span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mydict</span><span class="p">:</span></pre><div class="notes"><p>"in" has been the norm since Python 2.2. It's been 15 years. has_key
doesn't even exist in Python 3. And you probably think I'm silly for
mentioning this. Let me present to you, github search!</p></div></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><img src="images/has_key_usage_1.png"></img><img src="images/has_key_usage_2.png"></img><div class="notes"><p>Yes, when you search for has_key on github, it tends to show every few
minutes or so. Not that people add it very often, but they are maintaining
code that still uses has_key() without changing it.</p></div></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><img src="images/has_key_commit_1.png" width="100%"></img><div class="notes"><p>I even found this! But don't worry, the actual commit replaces has_key
with in. It's just the commit message that is backwards.</p><p>But hey, it's a dog, I'm impressed it knows git!</p></div></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="16000" data-y="0" data-z="0"><pre class="highlight code python"><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">mvd</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">mvd</span><span class="p">[</span><span class="n">key</span><span class="p">])</span></pre><div class="notes"><p>Here is another little thing you don't need to do: using the keys()
method to iterate over a list. It's not as common as has_keys() but
there is a fair amount of matches on githib for this.</p></div></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="17600" data-y="0" data-z="0"><pre class="highlight code python"><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">mvd</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">mvd</span><span class="p">[</span><span class="n">key</span><span class="p">])</span></pre><div class="notes"><p>Just skip the keys() call.</p><p>The code I showed before is from the latest version of Django,
but it's from a test, so...</p></div></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="19200" data-y="0" data-z="0"><img src="images/allowed.gif"></img><div class="notes"><p>But still, if you are using the keys() method at all,
you are probably doing it wrong.</p></div></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20800" data-y="0" data-z="0"><pre class="highlight code python"><span class="n">keys</span> <span class="o">=</span> <span class="n">mydict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span></pre><div class="notes"><p>This is also fairly common. But the keys method has different results in
Python 2.7 and Python 3. Only in Python 2 is it a list.</p></div></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="22400" data-y="0" data-z="0"><pre class="highlight code python"><span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mydict</span><span class="p">)</span></pre><div class="notes"><p>This is better, it will always make a list.</p></div></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="24000" data-y="0" data-z="0"><pre class="highlight code python"><span class="n">eater</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">mydict</span><span class="p">)</span></pre><div class="notes"><p>And if you want an iterator, this is the way to do it, although you
usually want an iterator because you want to iterate over it and you can
iterate over a dictionary without calling iter() first, so I don't know
why you ever would do this.</p><p>OK, enough about dictionaries, now let's talk about sets!</p></div></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="25600" data-y="0" data-z="0"><h1 id="sets">Sets</h1><p>Unique values</p><p>Fast lookup</p><div class="notes"><p>Sets are useful, the values in a set must be unique and lookup in sets
are fast.</p><p>Sets first appeared in Python 2.3. So what did you do before? What else
do we have that has Unique values and fast lookup?</p></div></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="27200" data-y="0" data-z="0"><pre class="highlight code python"><span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">list_of_things</span><span class="p">:</span>
    <span class="n">d</span><span class="p">[</span><span class="n">each</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

<span class="n">list_of_things</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span></pre><div class="notes"><p>Yes! Dictionary keys! So in fact I lied, this pattern isn't about sets,
it's also about dictionaries!</p><p>This code example makes a list unique by putting it into a dictionary
as keys with a value of None, and then getting a list of keys back.</p></div></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="28800" data-y="0" data-z="0"><pre class="highlight code python"><span class="n">list_of_things</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">list_of_things</span><span class="p">)</span></pre><div class="notes"><p>Today you would just do this instead.</p><p>Another usage of dictionary keys like this is when you wanted to do very
fast lookups. Checking if a value exists in a dictionary is way faster
than checking if it exists in a list.</p></div></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="30400" data-y="0" data-z="0"><h1 id="dicts-vs-lists"><tt>dicts</tt> vs <tt>lists</tt></h1><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Python 2.7</p></td><td><p>45x</p></td></tr><tr><td><p>Python 3.6</p></td><td><p>60x</p></td></tr><tr><td><p>PyPy 5.5</p></td><td><p>35x</p></td></tr></tbody></table><div class="notes"><p>This is simply looking if a value exists in a dictionary vs a list.
Data is random integers, the set is 200 random integers. Yes, just 200.</p><p>And as you see, dictionaries are <em>way</em> faster than lists. So it used to
be a pattern that if you needed to do that a lot, you used a dictionary.
If you see dict where all values always are None or zero, this maybe be
what is happening.</p><p>And this means that if you are making a lookup to see if some values
exist in a list, consider that maybe it should be a set instead.</p></div></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="32000" data-y="0" data-z="0"><h1 id="sets-vs-dicts"><tt>sets</tt> vs <tt>dicts</tt></h1><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Python 2.7</p></td><td><p>1.05x</p></td></tr><tr><td><p>Python 3.6</p></td><td><p>1.05x</p></td></tr><tr><td><p>PyPy 5.5</p></td><td><p>1.02x</p></td></tr></tbody></table><div class="notes"><p>And don't worry, sets are a little bit faster than dictionaries.</p><p>OK, enough with dictionaries for real now. Now lets talk about sorting.</p></div></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="33600" data-y="0" data-z="0"><img src="images/cookbook1.png"></img><div class="notes"><p>Remember I mentioned old books and tutorials? Yeah, this is from the
Python Cookbook as you can see. Probably 1st edition, from 2002. Why
people commit it to Github in 2016 I don't know.</p><p>Let's look at the code.</p></div></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="35200" data-y="0" data-z="0"><pre class="highlight code python"><span class="n">keys</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="n">keys</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
    <span class="k">print</span> <span class="n">x</span><span class="p">,</span></pre><div class="notes"><p>This makes a list from a dictionary, and then sorts it with the lists
sort() method. And that's was the only way to stort things in 2002,
making a list and sorting it. But since Python 2.4 we have the sorted()
builtin.</p></div></div><div class="step step-level-1" step="23" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="36800" data-y="0" data-z="0"><pre class="highlight code python"><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">x</span><span class="p">,</span></pre><div class="notes"><p>Much better. Because less lines means less bugs. And it also is more
robust to use sorted(), because sorted() takes any iterable. It can be a
list, set, generator or like in this case a dictionary. sort() only works
on lists.</p><p>Even better would have been if we could use a list comprehension, of
course. But we can't, because of the print statement.</p><p>Or... can we?</p></div></div><div class="step step-level-1" step="24" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="38400" data-y="0" data-z="0"><pre class="highlight code python"><span class="p">[</span><span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">' '</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">)]</span></pre><div class="notes"><p>Of course we can, print is a function in Python 3!</p></div></div><div class="step step-level-1" step="25" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="40000" data-y="0" data-z="0"><h1 id="stuck-on-python-2">Stuck on Python 2?</h1><h1 id="sucks-for-you">Sucks for you!</h1><div class="notes"><p>Just kidding.</p></div></div><div class="step step-level-1" step="26" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="41600" data-y="0" data-z="0"><pre class="highlight code python"><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>

<span class="p">[</span><span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">' '</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">)]</span></pre><div class="notes"><p>You <em>can</em> do this in Python 2 as well.</p><p>Calling sort() on an existing list is a little bit faster than calling
sorted on the list, since sorted() ends up creating a new list. But the
difference is very small, around 2%, less on PyPy.</p></div></div><div class="step step-level-1" step="27" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="43200" data-y="0" data-z="0"><pre class="highlight code python"><span class="n">vs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">vs</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="o">-</span><span class="nb">cmp</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span></pre><div class="notes"><p>However, the next old sorting pattern <em>is</em> all about speed. For that
reason it's the one that you are least likely to encounter, because
fixing it is a marked improvement. But that also means it's important
to fix it, so I will talk about it anyway.</p><p>This code, from a book about Django and Javascript, uses the standard way
of sorting a list by passing in a comparison function, in this case a
lambda.</p><p>comparison functions return 1, 0 or -1 to tell which item of the two is
larger, so by sticking a minus first you get a reverse sort.</p></div></div><div class="step step-level-1" step="28" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="44800" data-y="0" data-z="0"><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>len(l)</p></td><td><p># calls</p></td><td><p>Per item</p></td></tr><tr><td><p>4</p></td><td><p>6</p></td><td><p>1.5</p></td></tr><tr><td><p>10</p></td><td><p>22</p></td><td><p>2.2</p></td></tr><tr><td><p>100</p></td><td><p>528</p></td><td><p>5.28</p></td></tr><tr><td><p>40,000</p></td><td><p>342,541</p></td><td><p>8.56</p></td></tr></tbody></table><p class="ref">Reference: Jarret Hardie in Python Magazine</p><div class="notes"><p>Buuuut, the comparison function compares pairs, and the longer the list
is, the more possible pairings is there. You see that long lists have a lot
more calls per item.</p></div></div><div class="step step-level-1" step="29" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="46400" data-y="0" data-z="0"><pre class="highlight code python"><span class="n">vs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">vs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span></pre><div class="notes"><p>So therefore, a key argument to sort() and sorted() was introduced
already in Python 2.4.</p><p>The function now got much simpler, and has only one argument    .
But how does the statistics look for how many calls the function gets?</p></div></div><div class="step step-level-1" step="30" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="48000" data-y="0" data-z="0"><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>len(l)</p></td><td><p># calls</p></td><td><p>Per item</p></td></tr><tr><td><p>4</p></td><td><p>4</p></td><td><p>1</p></td></tr><tr><td><p>10</p></td><td><p>10</p></td><td><p>1</p></td></tr><tr><td><p>100</p></td><td><p>100</p></td><td><p>1</p></td></tr><tr><td><p>40,000</p></td><td><p>40,000</p></td><td><p>1</p></td></tr></tbody></table><div class="notes"><p>Yeah, you get exactly one call per item, always.</p><p>With the cmp function we get around 17 times as many calls to getitem
as for with a key function. Yeah, 17. The slow bit of sorting is still
the actual sorting, but this makes a big difference.</p><p>40.000 random integers take only around 20% of the time to sort with a
key function instead of a cmp function.</p></div></div><div class="step step-level-1" step="31" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="49600" data-y="0" data-z="0"><pre class="highlight code python"><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__cmp__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">cmp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">)</span></pre><div class="notes"><p>And just as the cmp comparison method is deprecated and gone under Python
3, so is the dunder cmp method on objects. Instead there are the so
called "rich comparison functions."</p></div></div><div class="step step-level-1" step="32" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="51200" data-y="0" data-z="0"><pre class="highlight code python"><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
       <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
       <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
       <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
       <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
       <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
       <span class="o">...</span></pre><div class="notes"><p>There are plenty of reasons to use these instead of __cmp__, like the
fact that some types may tested for equality, but not otherwise
comparable. You can for example test if a color object is the same as
another color object but which of the colours are bigger?</p><p>But __cmp__ has a big benefit, you only need to implement one method, not
six, and this has meant that people were reluctant to use it.</p></div></div><div class="step step-level-1" step="33" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="52800" data-y="0" data-z="0"><pre class="highlight code python"><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">total_ordering</span>

<span class="nd">@total_ordering</span>
<span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
       <span class="o">...</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
       <span class="o">...</span></pre><div class="notes"><p>Functools to the rescue. With total_ordering you only need to implement
__eq__ and either less than or greater than.</p></div></div><div class="step step-level-1" step="34" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="54400" data-y="0" data-z="0"><pre class="highlight code python"><span class="n">result</span> <span class="o">=</span> <span class="n">use_blank</span> <span class="ow">and</span> <span class="n">blank_value</span> <span class="ow">or</span> <span class="n">default</span></pre><div class="notes"><p>This looks like a logic expression, but it isn't. It's a sneaky
conditonal expression!</p><p>It means that if use_blank is True, then result
gets set to blank_value other wise it's set to default.</p><p>But blank_value was a argument. What if it is something that evaluates to
false, like a None or an empty set?</p><p>Yes: result will be default, not what you pass in as blank_value.</p></div></div><div class="step step-level-1" step="35" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="56000" data-y="0" data-z="0"><pre class="highlight code python"><span class="n">result</span> <span class="o">=</span> <span class="n">blank_value</span> <span class="k">if</span> <span class="n">use_blank</span> <span class="k">else</span> <span class="n">default</span></pre><div class="notes"><p>This is how to do a conditional expression. It only arrived in Python
2.5, because people couldn't agree on how it should look, and I agree
it's not very readable, the condition is in the middle, so I tend to only
use it if I have to, which is when I have to use an expression, like
HTML templates or similar.</p><p>Now, on to something slightly more complex, resource handling!</p></div></div><div class="step step-level-1" step="36" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="57600" data-y="0" data-z="0"><pre class="highlight code python"><span class="n">t</span> <span class="o">=</span> <span class="n">database</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">t</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a_bunch_of_records</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">DatabaseException</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">"Something went wrong!"</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">abort</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">t</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></pre><div class="notes"><p>Yeah, this also isn't very readable. It's a made up example that make
sure that the database transaction is aborted if something goes wrong,
and that it's closed at the end no matter what.</p><p>It's hard to read because it nests two try statements. try/except/finally
only happened in 2.5. Before that you had to nest one try/except inside a
try/finally, like this code, and it's those nested try statements that
make this code ugly.</p></div></div><div class="step step-level-1" step="37" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="59200" data-y="0" data-z="0"><pre class="highlight code python"><span class="n">t</span> <span class="o">=</span> <span class="n">database</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">t</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a_bunch_of_records</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
<span class="k">except</span> <span class="n">DatabaseException</span><span class="p">:</span>
    <span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">"Something went wrong!"</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">abort</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">t</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></pre><div class="notes"><p>Already this is better.</p></div></div><div class="step step-level-1" step="38" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="60800" data-y="0" data-z="0"><pre class="highlight code python"><span class="k">with</span> <span class="n">database</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="k">as</span> <span class="n">t</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">t</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">a_bunch_of_records</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">DatabaseException</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">"Something went wrong!"</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">abort</span><span class="p">()</span></pre><div class="notes"><p>But of course, even better is with a context manager.</p></div></div><div class="step step-level-1" step="39" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="62400" data-y="0" data-z="0"><pre class="highlight code python"><span class="k">class</span> <span class="nc">MagicResource</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># deallocate the object!</span></pre><div class="notes"><p>Another way to deallocate resources was __del__. This was never a good
idea, as __del__ isn't guaranteed to be called. A context manager would
be the solution instead.</p><p>For the reason that it never was a good idea, I thought deallocating things
in dunder del would be unusual.</p></div></div><div class="step step-level-1" step="40" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="64000" data-y="0" data-z="0"><img src="images/del_use1.png" width="75%"></img><div class="notes"><p>Boy was I wrong. There's tons of this. I think it's Java and C++ people
that do this when they switch to Python.</p></div></div><div class="step step-level-1" step="41" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="65600" data-y="0" data-z="0"><pre class="highlight code python"><span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="n">DatabaseException</span><span class="p">,</span> <span class="n">add_records</span><span class="p">,</span>
                  <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">keyword</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span></pre><div class="notes"><p>On the topic of context managers, unittests assertRaises is a
contextmanager in 2.7 and later.</p></div></div><div class="step step-level-1" step="42" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="67200" data-y="0" data-z="0"><pre class="highlight code python"><span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">assertRaises</span><span class="p">(</span><span class="n">DatabaseException</span><span class="p">):</span>
    <span class="n">add_records</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">keyword</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span></pre><div class="notes"><p>So much nicer.</p></div></div><div class="step step-level-1" step="43" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="68800" data-y="0" data-z="0"><pre class="highlight code python"><span class="kn">import</span> <span class="nn">tempfile</span>

<span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryDirectory</span><span class="p">()</span> <span class="k">as</span> <span class="nb">dir</span><span class="p">:</span>
    <span class="c1"># Do stuff</span></pre><div class="notes"><p>Also worth mentioning is that in Python 2.7 TemporaryFile and
NamedTemporaryFile are context managers. And in Python 3.2 and later
you also have TemporaryDirectory!</p></div></div><div class="step step-level-1" step="44" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="70400" data-y="0" data-z="0"><h1 id="id2">Stuck on Python 2?</h1><h1 id="id3">Sucks for you!</h1><div class="notes"><p>Next: Generators.</p></div></div><div class="step step-level-1" step="45" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="72000" data-y="0" data-z="0"><pre class="highlight code python"><span class="k">def</span> <span class="nf">a_generator</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">another_generator</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">x</span></pre><div class="notes"><p>Generators are awesome, I love generators. But this sort of code annoys
me every time. Why do I have to write such stupid code?</p></div></div><div class="step step-level-1" step="46" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="73600" data-y="0" data-z="0"><pre class="highlight code python"><span class="k">def</span> <span class="nf">a_generator</span><span class="p">():</span>
    <span class="k">yield from</span> <span class="n">another_generator</span><span class="p">()</span></pre><div class="notes"><p>In Python 3.3 and later, I don't!</p></div></div><div class="step step-level-1" step="47" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="75200" data-y="0" data-z="0"><h1 id="id4">Stuck on Python 2?</h1><h1 id="id5">Sucks for you!</h1><div class="notes"><p>Now this is not the only thing yield from does. It also changes how you
use coroutines.</p><p>But coroutines really require their own talk, but the most important for
this is that without yield from it's very hard to yield from a
subgenerator with Python coroutines.</p><p>It's in fact so hard that I can't even find a single example of it being
done without yield from. Python 2 coroutine example, yep, I can find that.
Python 2 coroutines with subroutines? <em>can't find em</em></p><p>But it requires you to do a lot of exception handling and closing of the
subroutine etc. Yield from does all that for you, it will let a subroutine
yield data directly to the called of the coroutine the correct way.</p><p>On the topic of Generators and coroutines, Python 3.7 will have a
backwards incompatible change I thought I should mention.</p></div></div><div class="step step-level-1" step="48" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="76800" data-y="0" data-z="0"><pre class="highlight code python"><span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">StopIteration</span>
    <span class="k">return</span> <span class="n">x</span></pre><div class="notes"><p>Generators are a type of iterators, and iterators is any object with a
__next__ method. You signal the end of the iteration by raising a
StopIteration exception.</p></div></div><div class="step step-level-1" step="49" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="78400" data-y="0" data-z="0"><pre class="highlight code python"><span class="k">def</span> <span class="nf">testgen</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">31</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">+</span><span class="n">x</span>
        <span class="k">yield</span> <span class="n">x</span></pre><div class="notes"><p>And so you should use StopIteration to stop the iteration ins a generator
as well, right? They are after all just fancy iterators, or?</p><p>Ah, well, no. This above does indeed work. But raising StopIteration in
generators can under specific circumstance cause some obscure bugs.</p></div></div><div class="step step-level-1" step="50" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="80000" data-y="0" data-z="0"><h1 id="pep-479">PEP 479</h1><div class="notes"><p>See PEP 479 if you want the details.</p></div></div><div class="step step-level-1" step="51" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="81600" data-y="0" data-z="0"><pre class="highlight code">&gt;&gt;&gt; list(testgen(0))
RuntimeError: generator raised StopIteration</pre><div class="notes"><p>The end result is in any case that starting from Python 3.7, raising a
StopIteration in a generator in fact raises a RuntimeError.</p></div></div><div class="step step-level-1" step="52" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="83200" data-y="0" data-z="0"><pre class="highlight code python"><span class="k">def</span> <span class="nf">testgen</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">31</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">+</span><span class="n">x</span>
        <span class="k">yield</span> <span class="n">x</span></pre><div class="notes"><p>The correct way is to just return. This will raise StopIteration.</p></div></div><div class="step step-level-1" step="53" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="84800" data-y="0" data-z="0"><pre class="highlight code python"><span class="k">def</span> <span class="nf">testgen</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">31</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">"Not an error anymore!"</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span><span class="o">+</span><span class="n">x</span>
        <span class="k">yield</span> <span class="n">x</span></pre><div class="notes"><p>And in Python 3.3 you can even pass an argument into StopIteration by
returning a value.</p><p>And this again has to do with coroutines, which are magic. So if you want to do coroutines, you need Python 3.</p></div></div><div class="step step-level-1" step="54" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="86400" data-y="0" data-z="0"><h1 id="id6">Stuck on Python 2?</h1><h1 id="id7">Sucks for you!</h1></div><div class="step step-level-1" step="55" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="88000" data-y="0" data-z="0"><pre class="highlight code python"><span class="bp">self</span><span class="o">.</span><span class="n">_leftover</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">''</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">bytes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leftover</span><span class="p">])</span></pre><p class="ref">Django 1.11.1: django/http/multipartparser.py</p><div class="notes"><p>And now, the prehistoric pattern that was the catalyst for this talk.
Concatinating strings by joining an empty string, like this example
from Django.</p><p>It's obvious it's old code, they have a variable called bytes.</p></div></div><div class="step step-level-1" step="56" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="89600" data-y="0" data-z="0"><pre class="highlight code python"><span class="bp">self</span><span class="o">.</span><span class="n">_leftover</span> <span class="o">=</span> <span class="nb">bytes</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leftover</span></pre><div class="notes"><p>Why not do this instead?</p><p>Well, you used to hear people claiming that concatenating strings with +
is slow, and that doing a join is faster. But, they say, since CPython
2.5 there are optimizations in string concatenation, so now it is fast, I
was told.</p><p>So let's look at the benchmarks.</p></div></div><div class="step step-level-1" step="57" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="91200" data-y="0" data-z="0"><h1 id="is-faster-than-join"><tt>+</tt> is faster than <tt>.join</tt></h1><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Python 2.4</p></td><td><p>3.0x</p></td></tr><tr><td><p>Python 2.7</p></td><td><p>2.7x</p></td></tr><tr><td><p>Python 3.6</p></td><td><p>2.1x</p></td></tr><tr><td><p>PyPy2 5.4</p></td><td><p>1.5x</p></td></tr><tr><td><p>PyPy3 5.5</p></td><td><p>1.2x</p></td></tr></tbody></table><div class="notes"><p>And you see that using addition to concatenate is faster.
Even on Python 2.4! So using join() was never faster!</p><p>So where does this claim that join is faster come from?
I think this is a big misunderstandning.</p></div></div><div class="step step-level-1" step="58" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="92800" data-y="0" data-z="0"><h1 id="this-is-slow">This is slow:</h1><pre class="highlight code python"><span class="n">result</span> <span class="o">=</span> <span class="s1">''</span>
<span class="k">for</span> <span class="n">text</span> <span class="ow">in</span> <span class="n">long_list_of_text</span><span class="p">():</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="n">text</span>
<span class="k">return</span> <span class="n">result</span></pre><div class="notes"><p>This code will be slow, but...</p></div></div><div class="step step-level-1" step="59" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="94400" data-y="0" data-z="0"><h1 id="much-faster">Much faster:</h1><pre class="highlight code python"><span class="n">texts</span> <span class="o">=</span> <span class="n">long_list_of_text</span><span class="p">()</span>
<span class="n">result</span> <span class="o">=</span> <span class="s1">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">texts</span><span class="p">)</span>
<span class="k">return</span> <span class="n">result</span></pre><div class="notes"><p>This code will be fast.</p></div></div><div class="step step-level-1" step="60" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="96000" data-y="0" data-z="0"><h1 id="join-is-faster-than"><tt>join</tt> is faster than <tt>+</tt></h1><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Python 2.4</p></td><td><p>2x</p></td></tr><tr><td><p>Python 2.7</p></td><td><p>2x</p></td></tr><tr><td><p>Python 3.6</p></td><td><p>2.5x</p></td></tr><tr><td><p>PyPy2 5.4</p></td><td><p>700x</p></td></tr><tr><td><p>PyPy3 5.5</p></td><td><p>700x</p></td></tr></tbody></table><div class="notes"><p>Join is WAY faster when joining an existing list of strings. This is
native strings. With Unicode the difference under Python 2 is around 200
times!</p></div></div><div class="step step-level-1" step="61" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="97600" data-y="0" data-z="0"><pre class="highlight code python"><span class="n">result</span> <span class="o">=</span> <span class="s1">''</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">char</span></pre><h1 id="vs">vs.</h1><pre class="highlight code python"><span class="n">l</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
    <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">char</span><span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="s1">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">l</span><span class="p">)</span></pre><div class="notes"><p>But I discovered something interesting here. If you are actually generating
the strings in a loop, then it's faster to add in that loop than making a
list and then joining it!</p></div></div><div class="step step-level-1" step="62" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="99200" data-y="0" data-z="0"><h1 id="is-faster-than-join-again"><tt>+</tt> is faster than <tt>.join</tt> again!</h1><p>With native strings</p><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Python 2.4</p></td><td><p>2.2x</p></td></tr><tr><td><p>Python 2.7</p></td><td><p>2.1x</p></td></tr><tr><td><p>Python 3.6</p></td><td><p>1.9x</p></td></tr><tr><td><p>PyPy2 5.4</p></td><td><p>0.01x</p></td></tr><tr><td><p>PyPy3 5.5</p></td><td><p>0.02x</p></td></tr></tbody></table><div class="notes"><p>Except on PyPy!</p><p>This is native strings, so byte strings on Python 2, Unicode on Python 3.</p></div></div><div class="step step-level-1" step="63" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="100800" data-y="0" data-z="0"><h1 id="but-join-is-still-faster-than">But <tt>.join</tt> is still faster than <tt>+</tt>!</h1><p>With non-native strings</p><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Python 2.4</p></td><td><p>17x</p></td></tr><tr><td><p>Python 2.7</p></td><td><p>27x</p></td></tr><tr><td><p>Python 3.6</p></td><td><p>34x</p></td></tr><tr><td><p>PyPy2 5.4</p></td><td><p>67x</p></td></tr><tr><td><p>PyPy3 5.5</p></td><td><p>83x</p></td></tr></tbody></table></div><div class="step step-level-1" step="64" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="102400" data-y="0" data-z="0"><h1 id="constants-and-loops">Constants and Loops</h1><pre class="highlight code python"><span class="n">const</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="mf">3.5</span>
<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">some_iterable</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="n">const</span></pre><div class="notes"><p>This is a pattern that was suggested to me that I should bring up.
And I wasn't going to do it until I started benchmarking it.</p><p>Here we see something simple, calculating a constant outside the loop.
That should speed up the loop, right because you don't have to calculate
the constant, right?</p></div></div><div class="step step-level-1" step="65" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="104000" data-y="0" data-z="0"><h1 id="id8">Constants and Loops</h1><pre class="highlight code python"><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">some_iterable</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="mi">5</span> <span class="o">*</span> <span class="mf">3.5</span></pre><div class="notes"><p>This should reasonably be slower.
But the claim is that it isn't anymore. CPython optimizes this, since 2.5.</p></div></div><div class="step step-level-1" step="66" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="105600" data-y="0" data-z="0"><h1 id="outside-vs-inside">Outside vs Inside</h1><h2 id="id9"><tt>5 * 3.5</tt></h2><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Python 2.4</p></td><td><p>2.0x</p></td></tr><tr><td><p>Python 2.7</p></td><td><p>1.0x</p></td></tr><tr><td><p>Python 3.6</p></td><td><p>1.0x</p></td></tr><tr><td><p>PyPy2  5.4</p></td><td><p>1.0x</p></td></tr><tr><td><p>PyPy2  5.5</p></td><td><p>1.0x</p></td></tr></tbody></table><div class="notes"><p>And yup. It used to be much faster to calculate it outside of the loop,
but since Python 2.5 it isn't. CPython will find that multiplication and
calculate only once.</p></div></div><div class="step step-level-1" step="67" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="107200" data-y="0" data-z="0"><h1 id="id10">Outside vs Inside</h1><h2 id="id11"><tt>5 / 3.5</tt></h2><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Python 2.4</p></td><td><p>2.0x</p></td></tr><tr><td><p>Python 2.7</p></td><td><p>2.0x</p></td></tr><tr><td><p>Python 3.6</p></td><td><p>1.0x</p></td></tr><tr><td><p>PyPy2 5.4</p></td><td><p>1.0x</p></td></tr><tr><td><p>PyPy3 5.5</p></td><td><p>1.0x</p></td></tr></tbody></table><div class="notes"><p>But if you have a division in the calculation, the Python 2.7
gets slow again!</p><p>Python 3 and PyPy are still fine, though.</p><p>But of course, my example is stupid.</p></div></div><div class="step step-level-1" step="68" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="108800" data-y="0" data-z="0"><p><tt>result = len(some_iterable) * 17.5</tt></p><div class="notes"><p>It can be replaced with this. Which is about 250 times faster. Except
on PyPy where it's just 10 times faster. Which is still twice as fast as
Python 2.7.</p><p>So, let us take some less stupid example.</p></div></div><div class="step step-level-1" step="69" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="110400" data-y="0" data-z="0"><h1 id="id12">Outside vs Inside</h1><pre class="highlight code python"><span class="n">const</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">a_var</span>
<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">each</span> <span class="ow">in</span> <span class="n">some_iterable</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="n">each</span> <span class="o">*</span> <span class="n">const</span></pre><div class="notes"><p>Here the value we add is dependent on both the iterator variable and a
local variable. This is more realistic.</p></div></div><div class="step step-level-1" step="70" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="112000" data-y="0" data-z="0"><h1 id="id13">Outside vs Inside</h1><h2 id="each-5-a-var"><tt>each * 5 * a_var</tt></h2><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Python 2.4</p></td><td><p>1.3x</p></td></tr><tr><td><p>Python 2.7</p></td><td><p>1.3x</p></td></tr><tr><td><p>Python 3.6</p></td><td><p>1.3x</p></td></tr><tr><td><p>PyPy2 5.4</p></td><td><p>1.0x</p></td></tr><tr><td><p>PyPy3 5.5</p></td><td><p>1.0x</p></td></tr></tbody></table><div class="notes"><p>Now the optimization dissappeared On CPython 3 as well. Calculating the
constant outside of the loop is now faster again.</p><p>PyPy still succeeds in optimizing this.</p></div></div><div class="step step-level-1" step="71" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="113600" data-y="0" data-z="0"><h1 id="id14">Outside vs Inside</h1><h2 id="id15"><tt>each * 5 ** a_var</tt></h2><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Python 2.4</p></td><td><p>1.8x</p></td></tr><tr><td><p>Python 2.7</p></td><td><p>2.0x</p></td></tr><tr><td><p>Python 3.6</p></td><td><p>2.0x</p></td></tr><tr><td><p>PyPy2 5.4</p></td><td><p>29x</p></td></tr><tr><td><p>PyPy3 5.5</p></td><td><p>2.2x</p></td></tr></tbody></table><div class="notes"><p>Unless you use a power in the calculation of the constant,
where PyPy's optimization also dissapears to the point of calculating it
inside the loop is around 30x slower!</p><p>So this pattern turns out not to be prehistoric at all!</p><p>So, you <em>should</em> calculate constants outside of the loop.</p><p>And it's the same with calculating constants outside of the loop.
It feels like it should be faster, and it often is.</p></div></div><div class="step step-level-1" step="72" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="115200" data-y="0" data-z="0"><h1 id="conclusion">Conclusion</h1><p>Python is awesome</p><div class="notes"><p>Except the conclusions that you should test your code, and not optmize
without benchmarks, my takeaway from writing this talk is that
Python is awesome.</p><p>Python is such a fantastic language partly because what intuitively feels
like the right thing to do, tends to in fact be the right thing to do.
The short, readable code most of the time tends to be the fastest code.
Not always, but mostly.</p></div></div><div class="step step-level-1" step="73" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="116800" data-y="0" data-z="0"><h1 id="thanks">Thanks!</h1><p>Thanks to everyone who suggested outdated idioms, even if I didn't include them:</p><p>Radomir Dopieralski,
James Tauber,
Sasha Matijasic,
Brad Allen,
Antonio Sagliocco,
Doug Hellman,
Domen Ko&#x17E;ar,
Christophe Simonis</p><h2 id="made-with-hovercraft">Made with Hovercraft!</h2><p><a href="http://slides.colliberty.com/PyConUS-2017/">http://slides.colliberty.com/PyConUS-2017/</a></p></div><div class="step step-level-1" step="74" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="118400" data-y="0" data-z="0"><h1 id="end">End</h1></div></div><div class="footer"><img src="images/shoobx.png"></img></div><div id="hovercraft-help" class="hide"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>